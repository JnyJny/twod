{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"twod - A Two-Dimensional Geometry Library for Humans\u2122","text":"<p>twod (pronounced \"two dee\") is a Python library that provides simple, intuitive two-dimensional geometric primitives designed for humans. It offers both traditional float-based and complex number-based implementations of fundamental geometric objects.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multiple Implementations: Choose between traditional float-based (<code>Point</code>, <code>Rect</code>) and complex number-based (<code>CPoint</code>, <code>CRect</code>) implementations</li> <li>Comprehensive Geometry: Points, rectangles, lines, and ellipses with full geometric operations</li> <li>Intuitive API: Human-friendly method names and comprehensive docstrings</li> <li>Performance Options: Complex number implementations leverage Python's optimized complex type</li> <li>Rich Operations: Full arithmetic operator support, geometric calculations, and spatial relationships</li> </ul>"},{"location":"#core-classes","title":"Core Classes","text":""},{"location":"#point-classes","title":"Point Classes","text":"<ul> <li><code>Point</code>: Traditional float-based 2D point with comprehensive geometric operations</li> <li><code>CPoint</code>: Complex number-based point implementation with similar API but leveraging Python's complex type</li> </ul>"},{"location":"#rectangle-classes","title":"Rectangle Classes","text":"<ul> <li><code>Rect</code>: Traditional rectangle using Point internally</li> <li><code>CRect</code>: Complex number-based rectangle using CPoint and mixins</li> </ul>"},{"location":"#additional-primitives","title":"Additional Primitives","text":"<ul> <li><code>Line</code>: Line segment with geometric operations like intersections, distances, and relationships</li> <li><code>Ellipse</code>: Ellipse with properties like area, perimeter, and eccentricity</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from twod import Point, Rect, Line\n\n# Create points\norigin = Point(0, 0)\ncorner = Point(10, 10)\n\n# Calculate distance\ndistance = origin.distance(corner)  # 14.142135623730951\n\n# Create a rectangle\nrect = Rect(origin, corner)\nprint(f\"Area: {rect.area}\")  # Area: 100.0\n\n# Create a line\nline = Line(origin, corner)\nprint(f\"Length: {line.length}\")  # Length: 14.142135623730951\nprint(f\"Angle: {line.angle_degrees}\")  # Angle: 45.0\n\n# Check if point is inside rectangle\ntest_point = Point(5, 5)\nprint(f\"Inside: {test_point.inside(rect.bottom_left, rect.top_right)}\")  # Inside: True\n</code></pre>"},{"location":"#why-twod","title":"Why twod?","text":"<ul> <li>Human-Friendly: Intuitive method names and clear documentation</li> <li>Flexible: Choose the implementation that best fits your needs</li> <li>Comprehensive: Full suite of geometric operations and relationships</li> <li>Well-Tested: Extensive test suite ensuring reliability</li> <li>Modern Python: Uses Python 3.10+ features like structural pattern matching</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to dive in? Check out the installation guide and quickstart tutorial to begin using twod in your projects.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Explore the complete API documentation:</p> <ul> <li>API Reference - Complete API documentation for all classes and modules</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>twod is open source and welcomes contributions! Visit the GitHub repository to report issues, suggest features, or contribute code.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page contains practical examples showing how to use twod for common geometric tasks.</p>"},{"location":"examples/#basic-point-operations","title":"Basic Point Operations","text":""},{"location":"examples/#creating-and-manipulating-points","title":"Creating and Manipulating Points","text":"<pre><code>from twod import Point\n\n# Different ways to create points\norigin = Point()                    # Point(0, 0)\np1 = Point(3, 4)                   # Point(3, 4)\np2 = Point(x=10, y=20)             # Point(10, 20)\np3 = Point((5, 6))                 # From tuple\np4 = Point([7, 8])                 # From list\n\n# Point arithmetic\nresult = p1 + p2                   # Point(13, 24)\ndifference = p2 - p1               # Point(7, 16)\nscaled = p1 * 2                    # Point(6, 8)\nhalved = p1 / 2                    # Point(1.5, 2.0)\n</code></pre>"},{"location":"examples/#distance-and-angle-calculations","title":"Distance and Angle Calculations","text":"<pre><code>from twod import Point\nimport math\n\np1 = Point(0, 0)\np2 = Point(3, 4)\n\n# Distance calculations\ndistance = p1.distance(p2)         # 5.0\ndist_squared = p1.distance_squared(p2)  # 25.0 (faster)\n\n# Polar coordinates\nradius = p2.radius                 # 5.0\nangle_rad = p2.radians             # 0.9272952180016122\nangle_deg = p2.degrees             # 53.13010235415598\n\n# Create point from polar coordinates\npolar_point = Point.from_polar(5, math.pi/4)  # Point(3.535..., 3.535...)\n</code></pre>"},{"location":"examples/#working-with-rectangles","title":"Working with Rectangles","text":""},{"location":"examples/#rectangle-creation-and-properties","title":"Rectangle Creation and Properties","text":"<pre><code>from twod import Point, Rect\n\n# Create rectangle from corners\nbottom_left = Point(10, 10)\ntop_right = Point(50, 30)\nrect = Rect(bottom_left, top_right)\n\n# Rectangle properties\nprint(f\"Width: {rect.width}\")         # Width: 40\nprint(f\"Height: {rect.height}\")       # Height: 20\nprint(f\"Area: {rect.area}\")           # Area: 800\nprint(f\"Center: {rect.center}\")       # Center: Point(30, 20)\n\n# Corner access\nprint(f\"Bottom-left: {rect.bottom_left}\")\nprint(f\"Top-right: {rect.top_right}\")\nprint(f\"Top-left: {rect.top_left}\")\nprint(f\"Bottom-right: {rect.bottom_right}\")\n</code></pre>"},{"location":"examples/#rectangle-operations","title":"Rectangle Operations","text":"<pre><code>from twod import Point, Rect\n\nrect = Rect(Point(0, 0), Point(10, 10))\n\n# Move rectangle\nmoved = rect + Point(5, 5)         # Moves to (5,5)-(15,15)\n\n# Scale rectangle\nscaled = rect * 2                  # Scales to (0,0)-(20,20)\n\n# Check if point is inside\ntest_point = Point(5, 5)\ninside = test_point.inside(rect.bottom_left, rect.top_right)  # True\n\n# Check if rectangles overlap\nrect2 = Rect(Point(5, 5), Point(15, 15))\n# Would need to implement overlap check manually or use spatial relationships\n</code></pre>"},{"location":"examples/#line-geometry","title":"Line Geometry","text":""},{"location":"examples/#line-creation-and-properties","title":"Line Creation and Properties","text":"<pre><code>from twod import Point, Line\n\n# Create line from two points\nstart = Point(0, 0)\nend = Point(6, 8)\nline = Line(start, end)\n\n# Line properties\nprint(f\"Length: {line.length}\")           # Length: 10.0\nprint(f\"Angle: {line.angle_degrees}\")     # Angle: 53.13010235415598\nprint(f\"Slope: {line.slope}\")             # Slope: 1.3333333333333333\nprint(f\"Midpoint: {line.midpoint}\")       # Midpoint: Point(3, 4)\n\n# Direction and vector\nprint(f\"Direction: {line.direction}\")     # Unit vector\nprint(f\"Vector: {line.vector}\")           # Vector from start to end\n</code></pre>"},{"location":"examples/#line-intersections","title":"Line Intersections","text":"<pre><code>from twod import Point, Line\n\n# Create two intersecting lines\nline1 = Line(Point(0, 0), Point(4, 4))    # Diagonal line\nline2 = Line(Point(0, 4), Point(4, 0))    # Opposite diagonal\n\n# Find intersection\nintersection = line1.intersection_point(line2)\nprint(f\"Intersection: {intersection}\")     # Point(2, 2)\n\n# Check if lines intersect\nintersects = line1.intersects_line(line2)  # True\n\n# Parallel lines don't intersect\nline3 = Line(Point(0, 1), Point(4, 5))    # Parallel to line1\nno_intersection = line1.intersection_point(line3)  # None\n</code></pre>"},{"location":"examples/#distance-from-point-to-line","title":"Distance from Point to Line","text":"<pre><code>from twod import Point, Line\n\n# Horizontal line\nline = Line(Point(0, 0), Point(10, 0))\n\n# Points at various positions\npoint_on_line = Point(5, 0)\npoint_above = Point(5, 3)\npoint_below = Point(5, -2)\n\n# Calculate distances\ndist1 = line.distance_to_point(point_on_line)  # 0.0\ndist2 = line.distance_to_point(point_above)    # 3.0\ndist3 = line.distance_to_point(point_below)    # 2.0\n\n# Find closest point on line\nclosest = line.closest_point_on_line(point_above)  # Point(5, 0)\n</code></pre>"},{"location":"examples/#complex-number-points","title":"Complex Number Points","text":""},{"location":"examples/#using-cpoint-for-performance","title":"Using CPoint for Performance","text":"<pre><code>from twod import CPoint\n\n# Create from complex number\ncp1 = CPoint(3+4j)\ncp2 = CPoint(1+2j)\n\n# Arithmetic operations (leverages complex number efficiency)\nsum_cp = cp1 + cp2                 # CPoint(4+6j)\ndiff_cp = cp1 - cp2                # CPoint(2+2j)\nproduct = cp1 * cp2                # Complex multiplication\n\n# Polar operations are very efficient\nradius = cp1.radius                # 5.0\nangle = cp1.radians                # 0.9272952180016122\n\n# Create from polar coordinates\npolar_cp = CPoint.from_polar(5, 1.57)  # Approximately 5j\n</code></pre>"},{"location":"examples/#flexible-cpoint-construction","title":"Flexible CPoint Construction","text":"<pre><code>from twod import CPoint\n\n# Various ways to create CPoint\ncp1 = CPoint.from_any(3+4j)           # From complex\ncp2 = CPoint.from_any((3, 4))         # From tuple\ncp3 = CPoint.from_any([3, 4])         # From list\ncp4 = CPoint.from_any({\"x\": 3, \"y\": 4})  # From dict\ncp5 = CPoint.from_any(\"3+4j\")         # From string\ncp6 = CPoint.from_any(5)              # From scalar (5+0j)\n\n# All create equivalent points\nassert cp1 == cp2 == cp3 == cp4 == cp5\n</code></pre>"},{"location":"examples/#geometric-relationships","title":"Geometric Relationships","text":""},{"location":"examples/#collinearity-and-orientation","title":"Collinearity and Orientation","text":"<pre><code>from twod import Point, ColinearPoints\n\n# Check if three points are collinear\np1 = Point(0, 0)\np2 = Point(1, 1)\np3 = Point(2, 2)\n\ncollinear = p1.is_colinear(p2, p3)  # True\n\n# Check counter-clockwise orientation\np4 = Point(1, 2)\ntry:\n    ccw = p1.is_ccw(p2, p4)         # True\nexcept ColinearPoints:\n    print(\"Points are collinear\")\n</code></pre>"},{"location":"examples/#line-relationships","title":"Line Relationships","text":"<pre><code>from twod import Point, Line\n\n# Create various lines\nhorizontal = Line(Point(0, 0), Point(5, 0))\nvertical = Line(Point(0, 0), Point(0, 5))\ndiagonal = Line(Point(0, 0), Point(3, 4))\n\n# Check relationships\nperpendicular = horizontal.perpendicular_to(vertical)  # True\nparallel = horizontal.parallel_to(Line(Point(0, 1), Point(5, 1)))  # True\n\n# Calculate angles between lines\nangle = horizontal.angle_between(diagonal)  # In radians\n</code></pre>"},{"location":"examples/#practical-applications","title":"Practical Applications","text":""},{"location":"examples/#bounding-box-calculation","title":"Bounding Box Calculation","text":"<pre><code>from twod import Point, Rect\n\n# Set of points\npoints = [\n    Point(10, 5),\n    Point(20, 15),\n    Point(5, 10),\n    Point(15, 8),\n    Point(12, 20)\n]\n\n# Find bounding box\nmin_x = min(p.x for p in points)  # 5\nmax_x = max(p.x for p in points)  # 20\nmin_y = min(p.y for p in points)  # 5\nmax_y = max(p.y for p in points)  # 20\n\nbounding_box = Rect(Point(min_x, min_y), Point(max_x, max_y))\nprint(f\"Bounding box: {bounding_box}\")\n</code></pre>"},{"location":"examples/#polygon-perimeter","title":"Polygon Perimeter","text":"<pre><code>from twod import Point\n\n# Simple polygon (triangle)\nvertices = [\n    Point(0, 0),\n    Point(3, 0),\n    Point(1.5, 2.6),\n    Point(0, 0)  # Close the polygon\n]\n\n# Calculate perimeter\nperimeter = sum(\n    vertices[i].distance(vertices[i+1]) \n    for i in range(len(vertices)-1)\n)\nprint(f\"Perimeter: {perimeter}\")\n</code></pre>"},{"location":"examples/#collision-detection","title":"Collision Detection","text":"<pre><code>from twod import Point, Line\n\ndef lines_intersect(line1, line2):\n    \"\"\"Check if two line segments intersect.\"\"\"\n    return line1.intersects_line(line2)\n\ndef point_in_circle(point, center, radius):\n    \"\"\"Check if point is inside circle.\"\"\"\n    return point.distance(center) &lt;= radius\n\n# Example usage\nline1 = Line(Point(0, 0), Point(10, 10))\nline2 = Line(Point(0, 10), Point(10, 0))\n\nif lines_intersect(line1, line2):\n    intersection = line1.intersection_point(line2)\n    print(f\"Lines intersect at: {intersection}\")\n\n# Point in circle\ncenter = Point(5, 5)\ntest_point = Point(3, 4)\nif point_in_circle(test_point, center, 3):\n    print(\"Point is inside circle\")\n</code></pre>"},{"location":"examples/#performance-considerations","title":"Performance Considerations","text":""},{"location":"examples/#when-to-use-cpoint-vs-point","title":"When to Use CPoint vs Point","text":"<pre><code>from twod import Point, CPoint\nimport time\n\n# For simple operations, both are similar\np1 = Point(3, 4)\ncp1 = CPoint(3+4j)\n\n# For complex rotations, CPoint is more efficient\ndef rotate_point_traditional(point, angle):\n    \"\"\"Rotate using traditional trigonometry.\"\"\"\n    import math\n    cos_a = math.cos(angle)\n    sin_a = math.sin(angle)\n    return Point(\n        point.x * cos_a - point.y * sin_a,\n        point.x * sin_a + point.y * cos_a\n    )\n\ndef rotate_cpoint(cpoint, angle):\n    \"\"\"Rotate using complex number multiplication.\"\"\"\n    import cmath\n    rotation = cmath.exp(1j * angle)\n    return cpoint * CPoint(rotation)\n\n# CPoint rotation is typically faster for repeated operations\n</code></pre>"},{"location":"examples/#memory-and-speed-tips","title":"Memory and Speed Tips","text":"<pre><code>from twod import Point\n\n# Use distance_squared when you only need relative distances\npoints = [Point(i, i) for i in range(100)]\norigin = Point(0, 0)\n\n# Faster: compare squared distances\nclosest = min(points, key=lambda p: origin.distance_squared(p))\n\n# Slower: compare actual distances\n# closest = min(points, key=lambda p: origin.distance(p))\n</code></pre> <p>These examples demonstrate the core capabilities of twod. The library's consistent API makes it easy to work with geometric objects in an intuitive way.</p>"},{"location":"geometry-concepts/","title":"Geometry Concepts","text":"<p>This page explains the mathematical concepts and geometric principles underlying twod's design and functionality.</p>"},{"location":"geometry-concepts/#coordinate-systems","title":"Coordinate Systems","text":""},{"location":"geometry-concepts/#cartesian-coordinates","title":"Cartesian Coordinates","text":"<p>twod uses the standard Cartesian coordinate system where: - x-axis: Horizontal axis (positive goes right) - y-axis: Vertical axis (positive goes up) - Origin: Point (0, 0) where axes intersect</p> <pre><code>from twod import Point\n\norigin = Point(0, 0)\nright = Point(1, 0)    # 1 unit right\nup = Point(0, 1)       # 1 unit up\ndiagonal = Point(1, 1) # 1 unit right and up\n</code></pre>"},{"location":"geometry-concepts/#polar-coordinates","title":"Polar Coordinates","text":"<p>Points can also be represented in polar form using: - Radius \u00ae: Distance from origin - Angle (\u03b8): Angle from positive x-axis (counter-clockwise)</p> <pre><code>from twod import Point\nimport math\n\n# Create point from polar coordinates\nradius = 5\nangle = math.pi / 4  # 45 degrees\npoint = Point.from_polar(radius, angle)\nprint(f\"Point: {point}\")  # Point(3.535..., 3.535...)\n\n# Convert Cartesian to polar\np = Point(3, 4)\nprint(f\"Radius: {p.radius}\")  # 5.0\nprint(f\"Angle: {p.radians}\")  # 0.9272952180016122\n</code></pre>"},{"location":"geometry-concepts/#distance-calculations","title":"Distance Calculations","text":""},{"location":"geometry-concepts/#euclidean-distance","title":"Euclidean Distance","text":"<p>The distance between two points \\((x_1, y_1)\\) and \\((x_2, y_2)\\) is:</p> <p>\\[d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\\]</p> <pre><code>from twod import Point\n\np1 = Point(0, 0)\np2 = Point(3, 4)\ndistance = p1.distance(p2)  # 5.0\n</code></pre>"},{"location":"geometry-concepts/#distance-squared","title":"Distance Squared","text":"<p>For performance, when you only need relative distances, use squared distance:</p> <p>\\[d^2 = (x_2 - x_1)^2 + (y_2 - y_1)^2\\]</p> <pre><code>from twod import Point\n\np1 = Point(0, 0)\np2 = Point(3, 4)\ndist_squared = p1.distance_squared(p2)  # 25.0 (faster than distance)\n</code></pre>"},{"location":"geometry-concepts/#vector-operations","title":"Vector Operations","text":""},{"location":"geometry-concepts/#dot-product","title":"Dot Product","text":"<p>The dot product of two vectors a = (a\u2081, a\u2082) and b = (b\u2081, b\u2082) is:</p> <p>\\[\\mathbf{a} \\cdot \\mathbf{b} = a_1 b_1 + a_2 b_2\\]</p> <p>The dot product has important geometric properties: - Perpendicular vectors: dot product = 0 - Parallel vectors: dot product = \u00b1|a||b| - Angle between vectors: \\(\\cos \\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{|\\mathbf{a}||\\mathbf{b}|}\\)</p> <pre><code>from twod import Point\n\na = Point(3, 4)\nb = Point(1, 2)\ndot_product = a.dot(b)  # 3*1 + 4*2 = 11\n\n# Check if vectors are perpendicular\nperpendicular = Point(1, 0)\nvertical = Point(0, 1)\nprint(perpendicular.dot(vertical))  # 0 (perpendicular)\n</code></pre>"},{"location":"geometry-concepts/#cross-product-2d","title":"Cross Product (2D)","text":"<p>In 2D, the cross product gives a scalar representing the z-component of the 3D cross product:</p> <p>\\[\\mathbf{a} \\times \\mathbf{b} = a_1 b_2 - a_2 b_1\\]</p> <p>This is useful for: - Orientation: positive = counter-clockwise, negative = clockwise, zero = collinear - Area calculation: |cross product| = 2 \u00d7 area of triangle</p> <pre><code>from twod import Point\n\na = Point(1, 0)\nb = Point(0, 1)\ncross = a.cross(b)  # 1*1 - 0*0 = 1 (counter-clockwise)\n\n# Check orientation\np1 = Point(0, 0)\np2 = Point(1, 0)\np3 = Point(1, 1)\norientation = p1.ccw(p2, p3)  # &gt; 0 (counter-clockwise)\n</code></pre>"},{"location":"geometry-concepts/#line-geometry","title":"Line Geometry","text":""},{"location":"geometry-concepts/#line-representation","title":"Line Representation","text":"<p>Lines in twod are represented as line segments with start and end points. Key properties:</p> <ul> <li>Length: Distance between endpoints</li> <li>Direction: Unit vector from start to end</li> <li>Slope: Rise over run (dy/dx)</li> <li>Angle: Angle from positive x-axis</li> </ul> <pre><code>from twod import Point, Line\n\nline = Line(Point(0, 0), Point(3, 4))\nprint(f\"Length: {line.length}\")         # 5.0\nprint(f\"Direction: {line.direction}\")   # Unit vector (0.6, 0.8)\nprint(f\"Slope: {line.slope}\")           # 4/3 \u2248 1.333\nprint(f\"Angle: {line.angle_degrees}\")   # ~53.13\u00b0\n</code></pre>"},{"location":"geometry-concepts/#line-intersection","title":"Line Intersection","text":"<p>Two lines intersect if their direction vectors are not parallel. The intersection point can be found using parametric equations:</p> <ul> <li>Line 1: P\u2081 + t\u2081(P\u2082 - P\u2081)</li> <li>Line 2: P\u2083 + t\u2082(P\u2084 - P\u2083)</li> </ul> <pre><code>from twod import Point, Line\n\nline1 = Line(Point(0, 0), Point(2, 2))\nline2 = Line(Point(0, 2), Point(2, 0))\nintersection = line1.intersection_point(line2)  # Point(1, 1)\n</code></pre>"},{"location":"geometry-concepts/#distance-from-point-to-line","title":"Distance from Point to Line","text":"<p>The shortest distance from a point to a line segment involves: 1. Project the point onto the infinite line 2. Clamp the projection to the line segment 3. Calculate distance to the clamped point</p> <pre><code>from twod import Point, Line\n\nline = Line(Point(0, 0), Point(10, 0))  # Horizontal line\npoint = Point(5, 3)\ndistance = line.distance_to_point(point)  # 3.0\nclosest = line.closest_point_on_line(point)  # Point(5, 0)\n</code></pre>"},{"location":"geometry-concepts/#angle-calculations","title":"Angle Calculations","text":""},{"location":"geometry-concepts/#angle-between-vectors","title":"Angle Between Vectors","text":"<p>The angle between two vectors is found using the dot product:</p> <p>\\[\\theta = \\arccos\\left(\\frac{\\mathbf{a} \\cdot \\mathbf{b}}{|\\mathbf{a}||\\mathbf{b}|}\\right)\\]</p> <pre><code>from twod import Point, Line\nimport math\n\nline1 = Line(Point(0, 0), Point(1, 0))  # Horizontal\nline2 = Line(Point(0, 0), Point(1, 1))  # 45\u00b0 diagonal\n\nangle_rad = line1.angle_between(line2)  # \u03c0/4 radians\nangle_deg = angle_rad * 180 / math.pi   # 45 degrees\n</code></pre>"},{"location":"geometry-concepts/#angle-normalization","title":"Angle Normalization","text":"<p>Angles in twod are typically normalized to: - Radians: [0, 2\u03c0) or [-\u03c0, \u03c0) - Degrees: [0, 360\u00b0) or [-180\u00b0, 180\u00b0)</p>"},{"location":"geometry-concepts/#complex-number-geometry","title":"Complex Number Geometry","text":""},{"location":"geometry-concepts/#complex-numbers-as-points","title":"Complex Numbers as Points","text":"<p>Complex numbers provide an elegant way to represent 2D points: - Real part: x-coordinate - Imaginary part: y-coordinate - Magnitude: Distance from origin - Argument: Angle from positive x-axis</p> <pre><code>from twod import CPoint\n\n# Complex number 3+4j represents point (3, 4)\ncp = CPoint(3+4j)\nprint(f\"X: {cp.x}\")        # 3.0\nprint(f\"Y: {cp.y}\")        # 4.0\nprint(f\"Radius: {cp.radius}\")  # 5.0\nprint(f\"Angle: {cp.radians}\")  # 0.9272952180016122\n</code></pre>"},{"location":"geometry-concepts/#complex-arithmetic","title":"Complex Arithmetic","text":"<p>Complex number arithmetic naturally represents geometric operations: - Addition: Translation - Multiplication by real: Scaling - Multiplication by complex: Rotation and scaling</p> <pre><code>from twod import CPoint\nimport cmath\n\n# Translation\ncp1 = CPoint(1+2j)\ncp2 = CPoint(3+4j)\ntranslated = cp1 + cp2  # CPoint(4+6j)\n\n# Rotation by 90\u00b0 (multiply by i)\nrotated = cp1 * CPoint(1j)  # CPoint(-2+1j)\n\n# Rotation by arbitrary angle\nangle = 0.5  # radians\nrotation = cmath.exp(1j * angle)\nrotated = cp1 * CPoint(rotation)\n</code></pre>"},{"location":"geometry-concepts/#geometric-relationships","title":"Geometric Relationships","text":""},{"location":"geometry-concepts/#collinearity","title":"Collinearity","text":"<p>Three points are collinear if they lie on the same line. This can be tested using the cross product:</p> <pre><code>from twod import Point\n\np1 = Point(0, 0)\np2 = Point(1, 1)\np3 = Point(2, 2)\n\n# Points are collinear if cross product is zero\ncollinear = p1.is_colinear(p2, p3)  # True\n</code></pre>"},{"location":"geometry-concepts/#orientation","title":"Orientation","text":"<p>The orientation of three points can be: - Counter-clockwise: Cross product &gt; 0 - Clockwise: Cross product &lt; 0 - Collinear: Cross product = 0</p> <pre><code>from twod import Point\n\np1 = Point(0, 0)\np2 = Point(1, 0)\np3 = Point(1, 1)\n\nccw_test = p1.ccw(p2, p3)  # &gt; 0 (counter-clockwise)\nis_ccw = p1.is_ccw(p2, p3)  # True\n</code></pre>"},{"location":"geometry-concepts/#point-in-rectangle","title":"Point in Rectangle","text":"<p>A point is inside a rectangle if: - x-coordinate is between left and right bounds - y-coordinate is between bottom and top bounds</p> <pre><code>from twod import Point, Rect\n\nrect = Rect(Point(0, 0), Point(10, 10))\ntest_point = Point(5, 5)\n\n# Check if point is inside\ninside = test_point.inside(rect.bottom_left, rect.top_right)  # True\n</code></pre>"},{"location":"geometry-concepts/#performance-considerations","title":"Performance Considerations","text":""},{"location":"geometry-concepts/#squared-distance-vs-distance","title":"Squared Distance vs Distance","text":"<p>When comparing distances, use squared distance to avoid expensive square root calculation:</p> <pre><code>from twod import Point\n\npoints = [Point(1, 1), Point(2, 2), Point(3, 3)]\norigin = Point(0, 0)\n\n# Efficient: compare squared distances\nclosest = min(points, key=lambda p: origin.distance_squared(p))\n\n# Less efficient: compare actual distances\n# closest = min(points, key=lambda p: origin.distance(p))\n</code></pre>"},{"location":"geometry-concepts/#complex-vs-float-operations","title":"Complex vs Float Operations","text":"<p>Complex number operations can be more efficient for: - Rotations - Polar coordinate conversions - Repeated geometric transformations</p> <pre><code>from twod import Point, CPoint\n\n# Traditional rotation (slower)\ndef rotate_point(point, angle):\n    import math\n    cos_a = math.cos(angle)\n    sin_a = math.sin(angle)\n    return Point(\n        point.x * cos_a - point.y * sin_a,\n        point.x * sin_a + point.y * cos_a\n    )\n\n# Complex rotation (faster)\ndef rotate_cpoint(cpoint, angle):\n    import cmath\n    return cpoint * CPoint(cmath.exp(1j * angle))\n</code></pre>"},{"location":"geometry-concepts/#numerical-precision","title":"Numerical Precision","text":""},{"location":"geometry-concepts/#floating-point-considerations","title":"Floating Point Considerations","text":"<p>When working with floating-point numbers, be aware of: - Precision limits: Not all decimal numbers can be represented exactly - Comparison tolerance: Use tolerance for equality checks - Accumulated errors: Errors can accumulate in long calculations</p> <pre><code>from twod import Point\n\n# Floating point precision issues\np1 = Point(0.1, 0.2)\np2 = Point(0.3, 0.0)\nsum_point = p1 + p2  # May not be exactly Point(0.4, 0.2)\n\n# Use tolerance for comparisons\ndef points_equal(p1, p2, tolerance=1e-10):\n    return p1.distance(p2) &lt;= tolerance\n</code></pre>"},{"location":"geometry-concepts/#tolerance-in-geometric-operations","title":"Tolerance in Geometric Operations","text":"<p>Many geometric operations in twod use tolerance for robust comparisons:</p> <pre><code>from twod import Point, Line\n\nline = Line(Point(0, 0), Point(10, 0))\npoint = Point(5, 1e-12)  # Very close to line\n\n# Contains point uses tolerance\ncontains = line.contains_point(point)  # True (within default tolerance)\ncontains_strict = line.contains_point(point, tolerance=1e-15)  # False\n</code></pre> <p>Understanding these concepts will help you use twod effectively and write robust geometric code.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>twod requires Python 3.10 or higher. You can check your Python version with:</p> <pre><code>python --version\n</code></pre>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The easiest way to install twod is from PyPI using pip:</p> <pre><code>pip install twod\n</code></pre> <p>To upgrade to the latest version:</p> <pre><code>pip install --upgrade twod\n</code></pre>"},{"location":"installation/#install-from-source","title":"Install from Source","text":"<p>To install the latest development version from GitHub:</p> <pre><code>pip install git+https://github.com/JnyJny/twod.git\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to twod or modify the source code, you'll need a development installation:</p>"},{"location":"installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/JnyJny/twod.git\ncd twod\n</code></pre>"},{"location":"installation/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>The project uses <code>uv</code> for dependency management. Install it first:</p> <pre><code>pip install uv\n</code></pre> <p>Then sync the development dependencies:</p> <pre><code>uv sync --group dev --group docs\n</code></pre>"},{"location":"installation/#3-verify-installation","title":"3. Verify Installation","text":"<p>Run the tests to ensure everything is working:</p> <pre><code>pytest\n</code></pre> <p>Check code coverage:</p> <pre><code>poe coverage\n</code></pre> <p>Run type checking:</p> <pre><code>poe check\n</code></pre>"},{"location":"installation/#virtual-environment","title":"Virtual Environment","text":"<p>We recommend using a virtual environment to avoid conflicts with other packages:</p>"},{"location":"installation/#using-venv","title":"Using venv","text":"<pre><code>python -m venv twod-env\nsource twod-env/bin/activate  # On Windows: twod-env\\Scripts\\activate\npip install twod\n</code></pre>"},{"location":"installation/#using-conda","title":"Using conda","text":"<pre><code>conda create -n twod-env python=3.10\nconda activate twod-env\npip install twod\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>After installation, verify that twod is working correctly:</p> <pre><code>from twod import Point, Rect, Line\n\n# Test basic functionality\np1 = Point(0, 0)\np2 = Point(3, 4)\ndistance = p1.distance(p2)\nprint(f\"Distance: {distance}\")  # Should print: Distance: 5.0\n\n# Test complex number implementation\nfrom twod import CPoint\ncp = CPoint(3+4j)\nprint(f\"CPoint radius: {cp.radius}\")  # Should print: CPoint radius: 5.0\n</code></pre> <p>If this runs without errors, twod is successfully installed!</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#python-version-issues","title":"Python Version Issues","text":"<p>If you encounter issues with Python version compatibility:</p> <pre><code># Check your Python version\npython --version\n\n# If you have multiple Python versions, try:\npython3.10 -m pip install twod\n# or\npython3.11 -m pip install twod\n</code></pre>"},{"location":"installation/#import-errors","title":"Import Errors","text":"<p>If you get import errors, ensure you're in the correct environment:</p> <pre><code># Check which Python is being used\nwhich python\n\n# Check installed packages\npip list | grep twod\n</code></pre>"},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<p>For development, ensure all dependency groups are installed:</p> <pre><code>uv sync --group dev --group docs\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Now that you have twod installed, check out the quickstart guide to learn how to use it!</p>"},{"location":"performance/","title":"Performance Guide","text":"<p>This guide explains when to use different twod implementations and how to optimize performance for your specific use case.</p>"},{"location":"performance/#implementation-comparison","title":"Implementation Comparison","text":"<p>twod provides two main implementation approaches:</p>"},{"location":"performance/#traditional-float-based-classes","title":"Traditional Float-Based Classes","text":"<ul> <li>Classes: <code>Point</code>, <code>Rect</code></li> <li>Storage: Separate x, y float attributes</li> <li>Best for: General use, educational purposes, direct coordinate access</li> <li>Memory: Slightly more memory per object due to separate attributes</li> </ul>"},{"location":"performance/#complex-number-based-classes","title":"Complex Number-Based Classes","text":"<ul> <li>Classes: <code>CPoint</code>, <code>CRect</code></li> <li>Storage: Single complex number (x + yj)</li> <li>Best for: Performance-critical applications, rotations, polar operations</li> <li>Memory: More compact storage, single complex number</li> </ul>"},{"location":"performance/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"performance/#basic-operations","title":"Basic Operations","text":"<pre><code>import time\nfrom twod import Point, CPoint\n\n# Test data\nn = 100000\npoints_data = [(i, i+1) for i in range(n)]\n\n# Point creation\nstart = time.time()\npoints = [Point(x, y) for x, y in points_data]\npoint_time = time.time() - start\n\nstart = time.time()\ncpoints = [CPoint(x + y*1j) for x, y in points_data]\ncpoint_time = time.time() - start\n\nprint(f\"Point creation: {point_time:.3f}s\")\nprint(f\"CPoint creation: {cpoint_time:.3f}s\")\n</code></pre>"},{"location":"performance/#distance-calculations","title":"Distance Calculations","text":"<pre><code>import time\nfrom twod import Point, CPoint\n\n# Create test points\np1 = Point(0, 0)\np2 = Point(3, 4)\ncp1 = CPoint(0+0j)\ncp2 = CPoint(3+4j)\n\n# Distance calculation benchmark\nn = 1000000\n\nstart = time.time()\nfor _ in range(n):\n    dist = p1.distance(p2)\npoint_dist_time = time.time() - start\n\nstart = time.time()\nfor _ in range(n):\n    dist = cp1.distance(cp2)\ncpoint_dist_time = time.time() - start\n\nprint(f\"Point distance: {point_dist_time:.3f}s\")\nprint(f\"CPoint distance: {cpoint_dist_time:.3f}s\")\n</code></pre>"},{"location":"performance/#rotations","title":"Rotations","text":"<p>This is where complex numbers really shine:</p> <pre><code>import time\nimport math\nfrom twod import Point, CPoint\n\ndef rotate_point_traditional(point, angle):\n    \"\"\"Traditional rotation using trigonometry.\"\"\"\n    cos_a = math.cos(angle)\n    sin_a = math.sin(angle)\n    return Point(\n        point.x * cos_a - point.y * sin_a,\n        point.x * sin_a + point.y * cos_a\n    )\n\ndef rotate_cpoint_complex(cpoint, angle):\n    \"\"\"Rotation using complex number multiplication.\"\"\"\n    import cmath\n    rotation = cmath.exp(1j * angle)\n    return cpoint * CPoint(rotation)\n\n# Benchmark rotations\npoint = Point(3, 4)\ncpoint = CPoint(3+4j)\nangle = math.pi / 4  # 45 degrees\nn = 100000\n\nstart = time.time()\nfor _ in range(n):\n    rotated = rotate_point_traditional(point, angle)\ntraditional_time = time.time() - start\n\nstart = time.time()\nfor _ in range(n):\n    rotated = rotate_cpoint_complex(cpoint, angle)\ncomplex_time = time.time() - start\n\nprint(f\"Traditional rotation: {traditional_time:.3f}s\")\nprint(f\"Complex rotation: {complex_time:.3f}s\")\nprint(f\"Speedup: {traditional_time/complex_time:.1f}x\")\n</code></pre>"},{"location":"performance/#when-to-use-each-implementation","title":"When to Use Each Implementation","text":""},{"location":"performance/#use-pointrect-when","title":"Use Point/Rect When:","text":"<ol> <li> <p>Direct coordinate access is important <pre><code>from twod import Point\n\np = Point(3, 4)\n# Direct access to coordinates\nx_coord = p.x\ny_coord = p.y\n</code></pre></p> </li> <li> <p>Educational or learning contexts <pre><code># Clear, intuitive representation\npoint = Point(3, 4)\nprint(f\"Point at ({point.x}, {point.y})\")\n</code></pre></p> </li> <li> <p>Integration with existing float-based code <pre><code># Works naturally with existing functions expecting x, y\ndef process_coordinates(x, y):\n    return x * 2 + y\n\npoint = Point(3, 4)\nresult = process_coordinates(point.x, point.y)\n</code></pre></p> </li> <li> <p>Simple geometric calculations <pre><code>from twod import Point\n\n# Simple distance calculation\np1 = Point(0, 0)\np2 = Point(3, 4)\ndistance = p1.distance(p2)  # Clear and straightforward\n</code></pre></p> </li> </ol>"},{"location":"performance/#use-cpointcrect-when","title":"Use CPoint/CRect When:","text":"<ol> <li> <p>Performance is critical <pre><code>from twod import CPoint\n\n# Faster operations, especially for large datasets\npoints = [CPoint(x+y*1j) for x, y in large_dataset]\n</code></pre></p> </li> <li> <p>Frequent rotations or polar operations <pre><code>from twod import CPoint\nimport cmath\n\n# Efficient rotation\npoint = CPoint(3+4j)\nrotated = point * CPoint(cmath.exp(1j * angle))\n</code></pre></p> </li> <li> <p>Working with complex mathematical operations <pre><code>from twod import CPoint\n\n# Natural complex number operations\nz1 = CPoint(3+4j)\nz2 = CPoint(1+2j)\nproduct = z1 * z2  # Natural complex multiplication\n</code></pre></p> </li> <li> <p>Memory optimization <pre><code># More compact storage for large point collections\npoints = [CPoint(x+y*1j) for x, y in range(1000000)]\n</code></pre></p> </li> </ol>"},{"location":"performance/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"performance/#1-use-squared-distance-when-possible","title":"1. Use Squared Distance When Possible","text":"<pre><code>from twod import Point\n\n# When you only need relative distances\npoints = [Point(i, i) for i in range(100)]\norigin = Point(0, 0)\n\n# Efficient: compare squared distances (no sqrt)\nclosest = min(points, key=lambda p: origin.distance_squared(p))\n\n# Less efficient: compare actual distances\n# closest = min(points, key=lambda p: origin.distance(p))\n</code></pre>"},{"location":"performance/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>from twod import Point\n\n# Process multiple points efficiently\npoints = [Point(i, i) for i in range(1000)]\ntranslation = Point(10, 10)\n\n# Efficient batch translation\ntranslated = [p + translation for p in points]\n</code></pre>"},{"location":"performance/#3-pre-calculate-expensive-operations","title":"3. Pre-calculate Expensive Operations","text":"<pre><code>from twod import Point\nimport math\n\n# Pre-calculate trigonometric values for repeated rotations\nangle = math.pi / 4\ncos_angle = math.cos(angle)\nsin_angle = math.sin(angle)\n\ndef rotate_point_optimized(point, cos_a, sin_a):\n    return Point(\n        point.x * cos_a - point.y * sin_a,\n        point.x * sin_a + point.y * cos_a\n    )\n\n# Use pre-calculated values\npoints = [Point(i, i) for i in range(100)]\nrotated = [rotate_point_optimized(p, cos_angle, sin_angle) for p in points]\n</code></pre>"},{"location":"performance/#4-choose-appropriate-data-structures","title":"4. Choose Appropriate Data Structures","text":"<pre><code>from twod import Point\n\n# For spatial queries, consider using spatial data structures\n# This is a simple example - real applications might use KD-trees or R-trees\n\ndef find_nearby_points(target, points, radius):\n    \"\"\"Find points within radius of target.\"\"\"\n    radius_squared = radius * radius\n    return [p for p in points if target.distance_squared(p) &lt;= radius_squared]\n\n# Use squared distance for efficiency\ntarget = Point(0, 0)\npoints = [Point(i, j) for i in range(10) for j in range(10)]\nnearby = find_nearby_points(target, points, 5)\n</code></pre>"},{"location":"performance/#5-vectorize-operations-when-possible","title":"5. Vectorize Operations When Possible","text":"<pre><code>from twod import Point\nimport numpy as np\n\n# For very large datasets, consider NumPy for vectorized operations\ndef vectorized_distance(points1, points2):\n    \"\"\"Calculate distances between corresponding points using NumPy.\"\"\"\n    p1_array = np.array([(p.x, p.y) for p in points1])\n    p2_array = np.array([(p.x, p.y) for p in points2])\n    diff = p1_array - p2_array\n    return np.sqrt(np.sum(diff * diff, axis=1))\n\n# For very large datasets, this can be much faster\npoints1 = [Point(i, i) for i in range(10000)]\npoints2 = [Point(i+1, i+1) for i in range(10000)]\ndistances = vectorized_distance(points1, points2)\n</code></pre>"},{"location":"performance/#memory-usage","title":"Memory Usage","text":""},{"location":"performance/#memory-footprint-comparison","title":"Memory Footprint Comparison","text":"<pre><code>import sys\nfrom twod import Point, CPoint\n\n# Memory usage per object\npoint = Point(3, 4)\ncpoint = CPoint(3+4j)\n\nprint(f\"Point size: {sys.getsizeof(point)} bytes\")\nprint(f\"CPoint size: {sys.getsizeof(cpoint)} bytes\")\n\n# For large collections, this difference matters\nn = 100000\npoints = [Point(i, i) for i in range(n)]\ncpoints = [CPoint(i+i*1j) for i in range(n)]\n\n# Measure total memory usage\nimport tracemalloc\ntracemalloc.start()\n\n# Create point collection\npoint_collection = [Point(i, i) for i in range(n)]\ncurrent, peak = tracemalloc.get_traced_memory()\npoint_memory = current\n\ntracemalloc.clear_traces()\n\n# Create cpoint collection\ncpoint_collection = [CPoint(i+i*1j) for i in range(n)]\ncurrent, peak = tracemalloc.get_traced_memory()\ncpoint_memory = current\n\nprint(f\"Memory for {n} Points: {point_memory / 1024 / 1024:.2f} MB\")\nprint(f\"Memory for {n} CPoints: {cpoint_memory / 1024 / 1024:.2f} MB\")\n</code></pre>"},{"location":"performance/#memory-efficient-patterns","title":"Memory-Efficient Patterns","text":"<pre><code>from twod import CPoint\n\n# Use generators for large datasets\ndef generate_points(n):\n    \"\"\"Generate points on demand.\"\"\"\n    for i in range(n):\n        yield CPoint(i + i*1j)\n\n# Process points without storing all in memory\ntotal_distance = 0\norigin = CPoint(0)\nfor point in generate_points(1000000):\n    total_distance += origin.distance(point)\n    # Point is garbage collected after use\n</code></pre>"},{"location":"performance/#profiling-and-measurement","title":"Profiling and Measurement","text":""},{"location":"performance/#basic-timing","title":"Basic Timing","text":"<pre><code>import time\nfrom twod import Point, CPoint\n\ndef time_operation(operation, n=100000):\n    \"\"\"Time an operation n times.\"\"\"\n    start = time.time()\n    for _ in range(n):\n        operation()\n    return time.time() - start\n\n# Compare point creation\npoint_time = time_operation(lambda: Point(3, 4))\ncpoint_time = time_operation(lambda: CPoint(3+4j))\n\nprint(f\"Point creation: {point_time:.3f}s\")\nprint(f\"CPoint creation: {cpoint_time:.3f}s\")\n</code></pre>"},{"location":"performance/#using-timeit-for-accurate-measurements","title":"Using timeit for Accurate Measurements","text":"<pre><code>import timeit\nfrom twod import Point, CPoint\n\n# More accurate timing with timeit\nsetup = \"\"\"\nfrom twod import Point, CPoint\np1 = Point(0, 0)\np2 = Point(3, 4)\ncp1 = CPoint(0)\ncp2 = CPoint(3+4j)\n\"\"\"\n\npoint_time = timeit.timeit('p1.distance(p2)', setup=setup, number=100000)\ncpoint_time = timeit.timeit('cp1.distance(cp2)', setup=setup, number=100000)\n\nprint(f\"Point distance: {point_time:.3f}s\")\nprint(f\"CPoint distance: {cpoint_time:.3f}s\")\n</code></pre>"},{"location":"performance/#best-practices","title":"Best Practices","text":""},{"location":"performance/#1-choose-the-right-implementation","title":"1. Choose the Right Implementation","text":"<ul> <li>Point/Rect: For general use, learning, direct coordinate access</li> <li>CPoint/CRect: For performance-critical applications, rotations, large datasets</li> </ul>"},{"location":"performance/#2-measure-performance","title":"2. Measure Performance","text":"<ul> <li>Profile your specific use case</li> <li>Use appropriate timing tools</li> <li>Consider memory usage for large datasets</li> </ul>"},{"location":"performance/#3-optimize-appropriately","title":"3. Optimize Appropriately","text":"<ul> <li>Use squared distance when possible</li> <li>Pre-calculate expensive operations</li> <li>Consider vectorized operations for very large datasets</li> <li>Use generators for memory efficiency</li> </ul>"},{"location":"performance/#4-consider-trade-offs","title":"4. Consider Trade-offs","text":"<ul> <li>Readability vs Performance: Sometimes Point is clearer even if CPoint is faster</li> <li>Memory vs Speed: CPoint uses less memory but may be less intuitive</li> <li>Complexity vs Optimization: Don't optimize prematurely - measure first</li> </ul>"},{"location":"performance/#5-real-world-example","title":"5. Real-world Example","text":"<pre><code>from twod import Point, CPoint\nimport time\n\nclass ParticleSystem:\n    \"\"\"Example showing when to choose different implementations.\"\"\"\n\n    def __init__(self, use_complex=False):\n        self.use_complex = use_complex\n        self.particles = []\n\n    def add_particle(self, x, y):\n        if self.use_complex:\n            self.particles.append(CPoint(x + y*1j))\n        else:\n            self.particles.append(Point(x, y))\n\n    def update(self, dt):\n        \"\"\"Update particle positions - this is called frequently.\"\"\"\n        if self.use_complex:\n            # Complex number operations are faster for rotations\n            import cmath\n            rotation = cmath.exp(1j * dt)\n            self.particles = [p * CPoint(rotation) for p in self.particles]\n        else:\n            # Traditional approach\n            import math\n            cos_dt = math.cos(dt)\n            sin_dt = math.sin(dt)\n            new_particles = []\n            for p in self.particles:\n                new_x = p.x * cos_dt - p.y * sin_dt\n                new_y = p.x * sin_dt + p.y * cos_dt\n                new_particles.append(Point(new_x, new_y))\n            self.particles = new_particles\n\n# Benchmark particle systems\ntraditional = ParticleSystem(use_complex=False)\ncomplex_system = ParticleSystem(use_complex=True)\n\n# Add particles\nfor i in range(1000):\n    traditional.add_particle(i, i)\n    complex_system.add_particle(i, i)\n\n# Time updates\nstart = time.time()\nfor _ in range(100):\n    traditional.update(0.1)\ntraditional_time = time.time() - start\n\nstart = time.time()\nfor _ in range(100):\n    complex_system.update(0.1)\ncomplex_time = time.time() - start\n\nprint(f\"Traditional system: {traditional_time:.3f}s\")\nprint(f\"Complex system: {complex_time:.3f}s\")\nprint(f\"Speedup: {traditional_time/complex_time:.1f}x\")\n</code></pre> <p>This example shows how complex number-based operations can significantly improve performance for applications involving rotations and transformations.</p> <p>By understanding these performance characteristics, you can make informed decisions about which twod implementation to use for your specific needs.</p>"},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>This guide will get you up and running with twod in minutes. We'll cover the basic classes and operations you need to know.</p>"},{"location":"quickstart/#basic-point-operations","title":"Basic Point Operations","text":""},{"location":"quickstart/#creating-points","title":"Creating Points","text":"<pre><code>from twod import Point\n\n# Create points\norigin = Point()  # Defaults to (0, 0)\np1 = Point(3, 4)\np2 = Point(x=10, y=20)\n\n# From tuple or list\np3 = Point((5, 6))\np4 = Point([7, 8])\n\nprint(f\"Origin: {origin}\")  # Origin: Point(0, 0)\nprint(f\"P1: {p1}\")         # P1: Point(3, 4)\n</code></pre>"},{"location":"quickstart/#point-arithmetic","title":"Point Arithmetic","text":"<pre><code>from twod import Point\n\na = Point(1, 2)\nb = Point(3, 4)\n\n# Addition and subtraction\nc = a + b  # Point(4, 6)\nd = b - a  # Point(2, 2)\n\n# Multiplication and division\ne = a * 2    # Point(2, 4)\nf = b / 2    # Point(1.5, 2.0)\n\n# Dot product and cross product\ndot = a.dot(b)    # 11 (1*3 + 2*4)\ncross = a.cross(b)  # -2 (1*4 - 2*3)\n</code></pre>"},{"location":"quickstart/#distance-and-geometry","title":"Distance and Geometry","text":"<pre><code>from twod import Point\n\np1 = Point(0, 0)\np2 = Point(3, 4)\n\n# Distance calculations\ndistance = p1.distance(p2)  # 5.0\ndist_sq = p1.distance_squared(p2)  # 25.0\n\n# Midpoint\nmid = p1.midpoint(p2)  # Point(1.5, 2.0)\n\n# Polar coordinates\nradius = p2.radius  # 5.0\nangle = p2.degrees  # 53.13010235415598\n</code></pre>"},{"location":"quickstart/#complex-number-points","title":"Complex Number Points","text":"<p>For performance-critical applications, use <code>CPoint</code> which leverages Python's complex number type:</p> <pre><code>from twod import CPoint\n\n# Create from complex number\ncp1 = CPoint(3+4j)\ncp2 = CPoint.from_any((5, 6))  # Flexible constructor\n\n# Same operations as Point\ndistance = cp1.distance(cp2)\nmidpoint = cp1.midpoint(cp2)\n\n# Polar operations (efficient with complex numbers)\npolar_point = CPoint.from_polar(5, 0.927)  # radius=5, angle=0.927 radians\n</code></pre>"},{"location":"quickstart/#rectangles","title":"Rectangles","text":""},{"location":"quickstart/#creating-rectangles","title":"Creating Rectangles","text":"<pre><code>from twod import Point, Rect\n\n# From two points\nbottom_left = Point(0, 0)\ntop_right = Point(10, 20)\nrect = Rect(bottom_left, top_right)\n\n# Properties\nprint(f\"Width: {rect.width}\")    # Width: 10\nprint(f\"Height: {rect.height}\")  # Height: 20\nprint(f\"Area: {rect.area}\")      # Area: 200\nprint(f\"Center: {rect.center}\")  # Center: Point(5, 10)\n</code></pre>"},{"location":"quickstart/#rectangle-operations","title":"Rectangle Operations","text":"<pre><code>from twod import Point, Rect\n\nrect = Rect(Point(0, 0), Point(10, 10))\n\n# Check if point is inside\ntest_point = Point(5, 5)\ninside = test_point.inside(rect.bottom_left, rect.top_right)  # True\n\n# Rectangle arithmetic\nmoved_rect = rect + Point(5, 5)  # Moves rectangle by (5, 5)\nscaled_rect = rect * 2           # Scales rectangle by 2\n</code></pre>"},{"location":"quickstart/#lines","title":"Lines","text":""},{"location":"quickstart/#creating-and-using-lines","title":"Creating and Using Lines","text":"<pre><code>from twod import Point, Line\n\n# Create a line\nstart = Point(0, 0)\nend = Point(3, 4)\nline = Line(start, end)\n\n# Properties\nprint(f\"Length: {line.length}\")           # Length: 5.0\nprint(f\"Angle: {line.angle_degrees}\")     # Angle: 53.13010235415598\nprint(f\"Midpoint: {line.midpoint}\")       # Midpoint: Point(1.5, 2.0)\nprint(f\"Slope: {line.slope}\")             # Slope: 1.3333333333333333\n</code></pre>"},{"location":"quickstart/#line-operations","title":"Line Operations","text":"<pre><code>from twod import Point, Line\n\nline1 = Line(Point(0, 0), Point(2, 2))\nline2 = Line(Point(0, 2), Point(2, 0))\n\n# Intersection\nintersection = line1.intersection_point(line2)  # Point(1, 1)\nintersects = line1.intersects_line(line2)       # True\n\n# Distance from point to line\ntest_point = Point(1, 0)\ndistance = line1.distance_to_point(test_point)  # 0.7071067811865476\n\n# Line relationships\nhorizontal = Line(Point(0, 0), Point(5, 0))\nvertical = Line(Point(0, 0), Point(0, 5))\nperpendicular = horizontal.perpendicular_to(vertical)  # True\n</code></pre>"},{"location":"quickstart/#ellipses","title":"Ellipses","text":"<pre><code>from twod import Point, Ellipse\n\n# Create ellipse\ncenter = Point(0, 0)\nellipse = Ellipse(center, semi_major_axis=5, semi_minor_axis=3)\n\n# Properties\nprint(f\"Area: {ellipse.area}\")           # Area: 47.12388980384689\nprint(f\"Perimeter: {ellipse.perimeter}\") # Approximate perimeter\nprint(f\"Eccentricity: {ellipse.eccentricity}\")  # 0.8\n</code></pre>"},{"location":"quickstart/#choosing-between-implementations","title":"Choosing Between Implementations","text":""},{"location":"quickstart/#traditional-float-based-classes","title":"Traditional Float-Based Classes","text":"<ul> <li>Use when: You need familiar x, y coordinate access</li> <li>Classes: <code>Point</code>, <code>Rect</code></li> <li>Best for: General geometric calculations, educational purposes</li> </ul> <pre><code>from twod import Point, Rect\n\npoint = Point(3, 4)\nprint(f\"X: {point.x}, Y: {point.y}\")  # Direct coordinate access\n</code></pre>"},{"location":"quickstart/#complex-number-based-classes","title":"Complex Number-Based Classes","text":"<ul> <li>Use when: You need performance or work with rotations/polar coordinates</li> <li>Classes: <code>CPoint</code>, <code>CRect</code></li> <li>Best for: Performance-critical applications, complex geometric transformations</li> </ul> <pre><code>from twod import CPoint\n\npoint = CPoint(3+4j)\nprint(f\"Radius: {point.radius}\")       # Efficient polar coordinates\nrotated = point * (1+1j)               # Efficient rotation\n</code></pre>"},{"location":"quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/#finding-closest-point","title":"Finding Closest Point","text":"<pre><code>from twod import Point, Line\n\nline = Line(Point(0, 0), Point(10, 0))\ntest_point = Point(5, 3)\nclosest = line.closest_point_on_line(test_point)  # Point(5, 0)\n</code></pre>"},{"location":"quickstart/#checking-geometric-relationships","title":"Checking Geometric Relationships","text":"<pre><code>from twod import Point\n\n# Check if three points are collinear\np1, p2, p3 = Point(0, 0), Point(1, 1), Point(2, 2)\ncollinear = p1.is_colinear(p2, p3)  # True\n\n# Check counter-clockwise orientation\nccw = p1.is_ccw(p2, Point(1, 2))  # True\n</code></pre>"},{"location":"quickstart/#working-with-angles","title":"Working with Angles","text":"<pre><code>from twod import Point, Line\n\nline1 = Line(Point(0, 0), Point(1, 0))  # Horizontal\nline2 = Line(Point(0, 0), Point(1, 1))  # 45 degrees\n\nangle_rad = line1.angle_between(line2)  # \u03c0/4 radians\nangle_deg = angle_rad * 180 / 3.14159   # ~45 degrees\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore:</p> <ul> <li>Examples - More detailed usage examples</li> <li>API Reference - Complete method documentation</li> <li>Performance Guide - When to use different implementations</li> <li>Geometry Concepts - Mathematical background</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the complete API documentation for all twod classes and modules.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#point-classes","title":"Point Classes","text":"<ul> <li>Point - Traditional float-based 2D point with comprehensive geometric operations</li> <li>CPoint - Complex number-based point implementation with similar API</li> </ul>"},{"location":"api/#rectangle-classes","title":"Rectangle Classes","text":"<ul> <li>Rect - Traditional rectangle using Point internally</li> <li>CRect - Complex number-based rectangle using CPoint and mixins</li> </ul>"},{"location":"api/#additional-primitives","title":"Additional Primitives","text":"<ul> <li>Line - Line segment with geometric operations</li> <li>Ellipse - Ellipse with mathematical properties</li> </ul>"},{"location":"api/#supporting-modules","title":"Supporting Modules","text":"<ul> <li>Constants - Geometric constants and enumerations</li> <li>Exceptions - Custom exception classes</li> </ul>"},{"location":"api/#usage-notes","title":"Usage Notes","text":"<p>All classes support:</p> <ul> <li>Arithmetic Operations: Addition, subtraction, multiplication, division</li> <li>Comparison Operations: Equality, inequality</li> <li>Geometric Operations: Distance, angles, relationships</li> <li>Conversion Methods: Between coordinate systems and representations</li> </ul> <p>The API is designed to be intuitive and consistent across all classes, with comprehensive docstrings and type hints throughout.</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>twod<ul> <li>constants</li> <li>cpoint</li> <li>crect</li> <li>ellipse</li> <li>exceptions</li> <li>line</li> <li>mixins</li> <li>point</li> <li>rect</li> </ul> </li> </ul>"},{"location":"api/twod/","title":"twod","text":""},{"location":"api/twod/#twod","title":"<code>twod</code>","text":"<p>two-dimensional geometric objects for humans\u2122</p>"},{"location":"api/twod/#twod-classes","title":"Classes","text":""},{"location":"api/twod/#twod.CPoint","title":"<code>CPoint(x: float | int = 0, y: float | int = 0)</code>","text":""},{"location":"api/twod/#twod.CPoint-functions","title":"Functions","text":""},{"location":"api/twod/#twod.CPoint.ccw","title":"<code>ccw(b: Any, c: Any) -&gt; float</code>","text":"<p>Returns a float indicating the winding direction of the points [self, b, c].</p> <p>If result &gt; 0, clock-wise winding. If result &lt; 0, counter clock-wise winding (ccw). If result = 0, the three points are colinear.</p> <p>Note: ccw is also 2*area of the triangle [self, b, c]</p>"},{"location":"api/twod/#twod.Line","title":"<code>Line(start: Point = None, end: Point = None)</code>  <code>dataclass</code>","text":"<p>A line segment defined by two points.</p> <p>The Line class represents a geometric line segment with start and end points and provides many helpful properties and methods for geometric operations.</p> <p>line = Line(Point(0, 0), Point(3, 4)) line.length 5.0 line.angle_degrees 53.13010235415598</p>"},{"location":"api/twod/#twod.Line-attributes","title":"Attributes","text":""},{"location":"api/twod/#twod.Line.length","title":"<code>length: float</code>  <code>property</code>","text":"<p>The length of this line segment.</p>"},{"location":"api/twod/#twod.Line.length_squared","title":"<code>length_squared: float</code>  <code>property</code>","text":"<p>The squared length of this line segment (faster than length).</p>"},{"location":"api/twod/#twod.Line.vector","title":"<code>vector: Point</code>  <code>property</code>","text":"<p>The vector from start to end point.</p>"},{"location":"api/twod/#twod.Line.direction","title":"<code>direction: Point</code>  <code>property</code>","text":"<p>The unit vector in the direction from start to end.</p>"},{"location":"api/twod/#twod.Line.angle_radians","title":"<code>angle_radians: float</code>  <code>property</code>","text":"<p>The angle of this line in radians, measured counter-clockwise from positive x-axis.</p>"},{"location":"api/twod/#twod.Line.angle_degrees","title":"<code>angle_degrees: float</code>  <code>property</code>","text":"<p>The angle of this line in degrees, measured counter-clockwise from positive x-axis.</p>"},{"location":"api/twod/#twod.Line.slope","title":"<code>slope: float</code>  <code>property</code>","text":"<p>The slope of this line (rise over run).</p>"},{"location":"api/twod/#twod.Line.midpoint","title":"<code>midpoint: Point</code>  <code>property</code>","text":"<p>The midpoint of this line segment.</p>"},{"location":"api/twod/#twod.Line.is_point","title":"<code>is_point: bool</code>  <code>property</code>","text":"<p>True if this line has zero length (start == end).</p>"},{"location":"api/twod/#twod.Line.is_horizontal","title":"<code>is_horizontal: bool</code>  <code>property</code>","text":"<p>True if this line is horizontal (same y coordinates).</p>"},{"location":"api/twod/#twod.Line.is_vertical","title":"<code>is_vertical: bool</code>  <code>property</code>","text":"<p>True if this line is vertical (same x coordinates).</p>"},{"location":"api/twod/#twod.Line-functions","title":"Functions","text":""},{"location":"api/twod/#twod.Line.reverse","title":"<code>reverse() -&gt; Line</code>","text":"<p>Return a new line with start and end points swapped.</p>"},{"location":"api/twod/#twod.Line.extend","title":"<code>extend(distance: float, from_end: bool = True) -&gt; Line</code>","text":"<p>Extend the line by a given distance.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>Distance to extend (positive extends outward, negative inward)</p> required <code>from_end</code> <code>bool</code> <p>If True, extend from end point; if False, extend from start point</p> <code>True</code> <p>Returns:</p> Type Description <code>Line</code> <p>New Line extended by the specified distance</p>"},{"location":"api/twod/#twod.Line.point_at_parameter","title":"<code>point_at_parameter(t: float) -&gt; Point</code>","text":"<p>Get point on line at parameter t.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Parameter where 0 = start point, 1 = end point</p> required <p>Returns:</p> Type Description <code>Point</code> <p>Point on the line at parameter t</p>"},{"location":"api/twod/#twod.Line.distance_to_point","title":"<code>distance_to_point(point: Point) -&gt; float</code>","text":"<p>Calculate the shortest distance from a point to this line segment.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Point to calculate distance to</p> required <p>Returns:</p> Type Description <code>float</code> <p>Shortest distance from point to line segment</p>"},{"location":"api/twod/#twod.Line.closest_point_on_line","title":"<code>closest_point_on_line(point: Point) -&gt; Point</code>","text":"<p>Find the closest point on this line segment to the given point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Point to find closest point to</p> required <p>Returns:</p> Type Description <code>Point</code> <p>Closest point on the line segment</p>"},{"location":"api/twod/#twod.Line.intersects_line","title":"<code>intersects_line(other: Line) -&gt; bool</code>","text":"<p>Check if this line segment intersects with another line segment.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line segment to check intersection with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the line segments intersect</p>"},{"location":"api/twod/#twod.Line.intersection_point","title":"<code>intersection_point(other: Line) -&gt; Optional[Point]</code>","text":"<p>Find the intersection point of two line segments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line segment to find intersection with</p> required <p>Returns:</p> Type Description <code>Optional[Point]</code> <p>Intersection point if it exists, None otherwise</p>"},{"location":"api/twod/#twod.Line.parallel_to","title":"<code>parallel_to(other: Line) -&gt; bool</code>","text":"<p>Check if this line is parallel to another line.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line to check parallelism with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if lines are parallel</p>"},{"location":"api/twod/#twod.Line.perpendicular_to","title":"<code>perpendicular_to(other: Line) -&gt; bool</code>","text":"<p>Check if this line is perpendicular to another line.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line to check perpendicularity with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if lines are perpendicular</p>"},{"location":"api/twod/#twod.Line.angle_between","title":"<code>angle_between(other: Line) -&gt; float</code>","text":"<p>Calculate the angle between this line and another line in radians.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line to calculate angle with</p> required <p>Returns:</p> Type Description <code>float</code> <p>Angle between lines in radians (0 to \u03c0)</p>"},{"location":"api/twod/#twod.Line.contains_point","title":"<code>contains_point(point: Point, tolerance: float = 1e-10) -&gt; bool</code>","text":"<p>Check if a point lies on this line segment.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Point to check</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for floating point comparison</p> <code>1e-10</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if point lies on the line segment</p>"},{"location":"api/twod/#twod.Point","title":"<code>Point(x: float = 0.0, y: float = 0.0)</code>  <code>dataclass</code>","text":""},{"location":"api/twod/#twod.Point-attributes","title":"Attributes","text":""},{"location":"api/twod/#twod.Point.y","title":"<code>y: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A two dimensional geometric point.</p> <p>The Point class represents a geometric point with 'x' and 'y' attributes and has many helpful properties and methods.</p> <p>p = Point() p.is_origin True</p>"},{"location":"api/twod/#twod.Point.is_origin","title":"<code>is_origin: bool</code>  <code>property</code>","text":"<p>True if and only if x == 0 and y == 0.</p>"},{"location":"api/twod/#twod.Point.quadrant","title":"<code>quadrant: Quadrant</code>  <code>property</code>","text":"<p>The quadrant in the cartesian plane this point is located in.</p> <p>Possible values are: - Quadrant.FIRST - Quadrant.SECOND - Quadrant.THIRD - Quadrant.FOURTH - Quadrant.ORIGIN - Quadrant.X_AXIS - Quadrant.Y_AXIS</p>"},{"location":"api/twod/#twod.Point.radius","title":"<code>radius: float</code>  <code>property</code> <code>writable</code>","text":"<p>The distance from this point to the origin.</p>"},{"location":"api/twod/#twod.Point.radians","title":"<code>radians: float</code>  <code>property</code> <code>writable</code>","text":"<p>The angle in radians measured counter-clockwise from 3 o'clock.</p>"},{"location":"api/twod/#twod.Point.degrees","title":"<code>degrees: float</code>  <code>property</code> <code>writable</code>","text":"<p>The angle in degrees measured counter-clockwise from 3 o'clock.</p>"},{"location":"api/twod/#twod.Point.polar","title":"<code>polar: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Polar coordinates tuple: (R, \u03f4).</p> <p>R is the distance from the origin to this point. \u03f4 is the angle (radians) measured counter-clockwise from 3 o'clock.</p>"},{"location":"api/twod/#twod.Point.polar_deg","title":"<code>polar_deg: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Polar coordinates tuple: (R, \u03f4).</p> <p>R is the distance from the origin to this point. \u03f4 is the angle (degrees) measured counter-clockwise from 3 o'clock.</p>"},{"location":"api/twod/#twod.Point.xy","title":"<code>xy: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>A tuple of this point's x and y coordinates.</p>"},{"location":"api/twod/#twod.Point-functions","title":"Functions","text":""},{"location":"api/twod/#twod.Point.from_polar","title":"<code>from_polar(radius: float, theta: float, is_radians: bool = True, translate: Optional[Point] = None) -&gt; Point</code>  <code>classmethod</code>","text":"<p>Returns a Point with polar coordinates (R, \u03f4).</p> <p>The point is genrated relative to the origin.</p> <p>:param float radius: :param float theta: :param bool is_radians: :return: Point</p>"},{"location":"api/twod/#twod.Point.distance","title":"<code>distance(other: Optional[Point] = None) -&gt; float</code>","text":"<p>Return the floating point distance between self and other.</p> <p>If other is not given, the distance from self to the origin is returned.</p> <p>:param other: Point :return: float</p>"},{"location":"api/twod/#twod.Point.distance_squared","title":"<code>distance_squared(other: Optional[Point] = None) -&gt; float</code>","text":"<p>Return the floating point squared distance between self and other.</p> <p>If other is not given, the squared distance from self to the origin is returned.</p> <p>:param other: Point :return: float</p>"},{"location":"api/twod/#twod.Point.dot","title":"<code>dot(other: Point) -&gt; float</code>","text":"<p>Return a scalar dot product of self with other.</p> <p>:param other: Point :return: float</p>"},{"location":"api/twod/#twod.Point.cross","title":"<code>cross(other: Point) -&gt; float</code>","text":"<p>Return a scalar cross product of self with other.</p> <p>:param other: Point :return: float</p>"},{"location":"api/twod/#twod.Point.ccw","title":"<code>ccw(b: Point, c: Point) -&gt; float</code>","text":"<p>Return a floating point value indicating the winding direction of the points [self, b, c].</p> <p>If ccw &lt; 0,  clock-wise winding If ccw &gt; 0,  counter clock-wise winding If ccw == 0, the three points are colinear</p> <p>Note: ccw is also 2*area of the triangle [self, b, c].</p> <p>:param b: Point :param c: Point :return: float</p>"},{"location":"api/twod/#twod.Point.is_ccw","title":"<code>is_ccw(b: Point, c: Point) -&gt; bool</code>","text":"<p>Return True if the angle [self, b, c] has counter clock-wise winding, else False.</p> <p>Raises the exception ColinearPoints if the points compose a line.</p> <p>:param b: Point :param c: Point :return: bool</p>"},{"location":"api/twod/#twod.Point.is_colinear","title":"<code>is_colinear(b: Point, c: Point) -&gt; bool</code>","text":"<p>True if the angle [self, b, c ] is a line, else False.</p> <p>:param b: Point :param c: Point :return: bool</p>"},{"location":"api/twod/#twod.Point.midpoint","title":"<code>midpoint(other: Optional[Point] = None) -&gt; Point</code>","text":"<p>Return a new Point midway between self and other..</p> <p>If other is not given, the midpoint between self and the origin is returned.</p> <p>:param other: Point :return: Point</p>"},{"location":"api/twod/#twod.Point.between","title":"<code>between(p: Point, q: Point) -&gt; bool</code>","text":"<p>True if self is bounded by the points [p, q], else False</p> <p>The bounds are checked by less than or equal to (&lt;=) so self is considered between if it resides on any of the lines constructed using [p,q].</p> <p>:param p: Point :param q: Point :return: bool</p>"},{"location":"api/twod/#twod.Point.inside","title":"<code>inside(p: Point, q: Point) -&gt; bool</code>","text":"<p>True if point is bounded by the points (p, q), else False</p> <p>The bounds are checked by less than (&lt;) so point is considered inside if it does not reside on any of the lines constructed using (p,q).</p> <p>:param p: Point :param q: Point :return: bool</p>"},{"location":"api/twod/#twod.Rect","title":"<code>Rect(x: float | int = 0, y: float | int = 0, w: float | int = 0, h: float | int = 0)</code>","text":"<p>A rectangle specified by an origin at (x,y) and dimensions (w,h).</p>"},{"location":"api/twod/#twod.Rect-attributes","title":"Attributes","text":""},{"location":"api/twod/#twod.Rect.A","title":"<code>A: Point</code>  <code>property</code>","text":"<p>Point at (x,y).</p>"},{"location":"api/twod/#twod.Rect.B","title":"<code>B: Point</code>  <code>property</code>","text":"<p>Point at (x+w, y).</p>"},{"location":"api/twod/#twod.Rect.C","title":"<code>C: Point</code>  <code>property</code>","text":"<p>Point at (x+w, y+h).</p>"},{"location":"api/twod/#twod.Rect.D","title":"<code>D: Point</code>  <code>property</code>","text":"<p>Point at (x, y+h).</p>"},{"location":"api/twod/#twod.Rect.vertices","title":"<code>vertices: list[Point]</code>  <code>property</code>","text":"<p>The points A, B, C, and D in a list.</p>"},{"location":"api/twod/#twod.Rect.sides","title":"<code>sides: list[float]</code>  <code>property</code>","text":"<p>The lengths of each side: AB, BC, CD, and DA.</p>"},{"location":"api/twod/#twod.Rect.center","title":"<code>center: Point</code>  <code>property</code> <code>writable</code>","text":"<p>Point at the center of the rectangle (midpoint of AC).</p>"},{"location":"api/twod/#twod.Rect.perimeter","title":"<code>perimeter: float</code>  <code>property</code>","text":"<p>The distance around this rectangle.</p>"},{"location":"api/twod/#twod.Rect.area","title":"<code>area: float</code>  <code>property</code>","text":"<p>The area of this rectangle.</p>"},{"location":"api/twod/constants/","title":"constants","text":""},{"location":"api/twod/constants/#twod.constants","title":"<code>twod.constants</code>","text":"<p>geometric constants for humans\u2122</p>"},{"location":"api/twod/cpoint/","title":"cpoint","text":""},{"location":"api/twod/cpoint/#twod.cpoint","title":"<code>twod.cpoint</code>","text":""},{"location":"api/twod/cpoint/#twod.cpoint-classes","title":"Classes","text":""},{"location":"api/twod/cpoint/#twod.cpoint.CPoint","title":"<code>CPoint(x: float | int = 0, y: float | int = 0)</code>","text":""},{"location":"api/twod/cpoint/#twod.cpoint.CPoint-functions","title":"Functions","text":""},{"location":"api/twod/cpoint/#twod.cpoint.CPoint.ccw","title":"<code>ccw(b: Any, c: Any) -&gt; float</code>","text":"<p>Returns a float indicating the winding direction of the points [self, b, c].</p> <p>If result &gt; 0, clock-wise winding. If result &lt; 0, counter clock-wise winding (ccw). If result = 0, the three points are colinear.</p> <p>Note: ccw is also 2*area of the triangle [self, b, c]</p>"},{"location":"api/twod/crect/","title":"crect","text":""},{"location":"api/twod/crect/#twod.crect","title":"<code>twod.crect</code>","text":""},{"location":"api/twod/crect/#twod.crect-classes","title":"Classes","text":""},{"location":"api/twod/ellipse/","title":"ellipse","text":""},{"location":"api/twod/ellipse/#twod.ellipse","title":"<code>twod.ellipse</code>","text":"<p>an ellipse for humans\u2122</p>"},{"location":"api/twod/ellipse/#twod.ellipse-classes","title":"Classes","text":""},{"location":"api/twod/ellipse/#twod.ellipse.Ellipse","title":"<code>Ellipse(x: float = 0.0, y: float = 0.0, minor_axis: int = 0, major_axis: int = 0)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Point</code></p>"},{"location":"api/twod/ellipse/#twod.ellipse.Ellipse-attributes","title":"Attributes","text":""},{"location":"api/twod/ellipse/#twod.ellipse.Ellipse.e","title":"<code>e</code>  <code>property</code>","text":"<p>The eccentricity of this ellipse expressed as a float.</p>"},{"location":"api/twod/ellipse/#twod.ellipse.Ellipse.focus1","title":"<code>focus1</code>  <code>property</code>","text":"<p>The first focus of the ellipse.</p>"},{"location":"api/twod/ellipse/#twod.ellipse.Ellipse.focus2","title":"<code>focus2</code>  <code>property</code>","text":"<p>The second focus of the ellipse.</p>"},{"location":"api/twod/ellipse/#twod.ellipse.Ellipse.vertices","title":"<code>vertices</code>  <code>property</code>","text":"<p>A list of Points that are major_axis distance from the center of the ellipse on the x-axis.</p>"},{"location":"api/twod/ellipse/#twod.ellipse.Ellipse.co_vertices","title":"<code>co_vertices</code>  <code>property</code>","text":"<p>A list of Points that are minor_axis distance from the center of the ellipse on the y-axis.</p>"},{"location":"api/twod/ellipse/#twod.ellipse.Ellipse.is_circle","title":"<code>is_circle</code>  <code>property</code>","text":"<p>Returns True if this ellipse is also a circle.</p>"},{"location":"api/twod/exceptions/","title":"exceptions","text":""},{"location":"api/twod/exceptions/#twod.exceptions","title":"<code>twod.exceptions</code>","text":""},{"location":"api/twod/line/","title":"line","text":""},{"location":"api/twod/line/#twod.line","title":"<code>twod.line</code>","text":"<p>a line segment for humans\u2122</p>"},{"location":"api/twod/line/#twod.line-classes","title":"Classes","text":""},{"location":"api/twod/line/#twod.line.Line","title":"<code>Line(start: Point = None, end: Point = None)</code>  <code>dataclass</code>","text":"<p>A line segment defined by two points.</p> <p>The Line class represents a geometric line segment with start and end points and provides many helpful properties and methods for geometric operations.</p> <p>line = Line(Point(0, 0), Point(3, 4)) line.length 5.0 line.angle_degrees 53.13010235415598</p>"},{"location":"api/twod/line/#twod.line.Line-attributes","title":"Attributes","text":""},{"location":"api/twod/line/#twod.line.Line.length","title":"<code>length: float</code>  <code>property</code>","text":"<p>The length of this line segment.</p>"},{"location":"api/twod/line/#twod.line.Line.length_squared","title":"<code>length_squared: float</code>  <code>property</code>","text":"<p>The squared length of this line segment (faster than length).</p>"},{"location":"api/twod/line/#twod.line.Line.vector","title":"<code>vector: Point</code>  <code>property</code>","text":"<p>The vector from start to end point.</p>"},{"location":"api/twod/line/#twod.line.Line.direction","title":"<code>direction: Point</code>  <code>property</code>","text":"<p>The unit vector in the direction from start to end.</p>"},{"location":"api/twod/line/#twod.line.Line.angle_radians","title":"<code>angle_radians: float</code>  <code>property</code>","text":"<p>The angle of this line in radians, measured counter-clockwise from positive x-axis.</p>"},{"location":"api/twod/line/#twod.line.Line.angle_degrees","title":"<code>angle_degrees: float</code>  <code>property</code>","text":"<p>The angle of this line in degrees, measured counter-clockwise from positive x-axis.</p>"},{"location":"api/twod/line/#twod.line.Line.slope","title":"<code>slope: float</code>  <code>property</code>","text":"<p>The slope of this line (rise over run).</p>"},{"location":"api/twod/line/#twod.line.Line.midpoint","title":"<code>midpoint: Point</code>  <code>property</code>","text":"<p>The midpoint of this line segment.</p>"},{"location":"api/twod/line/#twod.line.Line.is_point","title":"<code>is_point: bool</code>  <code>property</code>","text":"<p>True if this line has zero length (start == end).</p>"},{"location":"api/twod/line/#twod.line.Line.is_horizontal","title":"<code>is_horizontal: bool</code>  <code>property</code>","text":"<p>True if this line is horizontal (same y coordinates).</p>"},{"location":"api/twod/line/#twod.line.Line.is_vertical","title":"<code>is_vertical: bool</code>  <code>property</code>","text":"<p>True if this line is vertical (same x coordinates).</p>"},{"location":"api/twod/line/#twod.line.Line-functions","title":"Functions","text":""},{"location":"api/twod/line/#twod.line.Line.reverse","title":"<code>reverse() -&gt; Line</code>","text":"<p>Return a new line with start and end points swapped.</p>"},{"location":"api/twod/line/#twod.line.Line.extend","title":"<code>extend(distance: float, from_end: bool = True) -&gt; Line</code>","text":"<p>Extend the line by a given distance.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>Distance to extend (positive extends outward, negative inward)</p> required <code>from_end</code> <code>bool</code> <p>If True, extend from end point; if False, extend from start point</p> <code>True</code> <p>Returns:</p> Type Description <code>Line</code> <p>New Line extended by the specified distance</p>"},{"location":"api/twod/line/#twod.line.Line.point_at_parameter","title":"<code>point_at_parameter(t: float) -&gt; Point</code>","text":"<p>Get point on line at parameter t.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Parameter where 0 = start point, 1 = end point</p> required <p>Returns:</p> Type Description <code>Point</code> <p>Point on the line at parameter t</p>"},{"location":"api/twod/line/#twod.line.Line.distance_to_point","title":"<code>distance_to_point(point: Point) -&gt; float</code>","text":"<p>Calculate the shortest distance from a point to this line segment.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Point to calculate distance to</p> required <p>Returns:</p> Type Description <code>float</code> <p>Shortest distance from point to line segment</p>"},{"location":"api/twod/line/#twod.line.Line.closest_point_on_line","title":"<code>closest_point_on_line(point: Point) -&gt; Point</code>","text":"<p>Find the closest point on this line segment to the given point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Point to find closest point to</p> required <p>Returns:</p> Type Description <code>Point</code> <p>Closest point on the line segment</p>"},{"location":"api/twod/line/#twod.line.Line.intersects_line","title":"<code>intersects_line(other: Line) -&gt; bool</code>","text":"<p>Check if this line segment intersects with another line segment.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line segment to check intersection with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the line segments intersect</p>"},{"location":"api/twod/line/#twod.line.Line.intersection_point","title":"<code>intersection_point(other: Line) -&gt; Optional[Point]</code>","text":"<p>Find the intersection point of two line segments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line segment to find intersection with</p> required <p>Returns:</p> Type Description <code>Optional[Point]</code> <p>Intersection point if it exists, None otherwise</p>"},{"location":"api/twod/line/#twod.line.Line.parallel_to","title":"<code>parallel_to(other: Line) -&gt; bool</code>","text":"<p>Check if this line is parallel to another line.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line to check parallelism with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if lines are parallel</p>"},{"location":"api/twod/line/#twod.line.Line.perpendicular_to","title":"<code>perpendicular_to(other: Line) -&gt; bool</code>","text":"<p>Check if this line is perpendicular to another line.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line to check perpendicularity with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if lines are perpendicular</p>"},{"location":"api/twod/line/#twod.line.Line.angle_between","title":"<code>angle_between(other: Line) -&gt; float</code>","text":"<p>Calculate the angle between this line and another line in radians.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Line</code> <p>Other line to calculate angle with</p> required <p>Returns:</p> Type Description <code>float</code> <p>Angle between lines in radians (0 to \u03c0)</p>"},{"location":"api/twod/line/#twod.line.Line.contains_point","title":"<code>contains_point(point: Point, tolerance: float = 1e-10) -&gt; bool</code>","text":"<p>Check if a point lies on this line segment.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>Point to check</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for floating point comparison</p> <code>1e-10</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if point lies on the line segment</p>"},{"location":"api/twod/mixins/","title":"mixins","text":""},{"location":"api/twod/mixins/#twod.mixins","title":"<code>twod.mixins</code>","text":""},{"location":"api/twod/mixins/#twod.mixins-classes","title":"Classes","text":""},{"location":"api/twod/point/","title":"point","text":""},{"location":"api/twod/point/#twod.point","title":"<code>twod.point</code>","text":"<p>a two-dimensional point for humans\u2122.</p>"},{"location":"api/twod/point/#twod.point-classes","title":"Classes","text":""},{"location":"api/twod/point/#twod.point.Point","title":"<code>Point(x: float = 0.0, y: float = 0.0)</code>  <code>dataclass</code>","text":""},{"location":"api/twod/point/#twod.point.Point-attributes","title":"Attributes","text":""},{"location":"api/twod/point/#twod.point.Point.y","title":"<code>y: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A two dimensional geometric point.</p> <p>The Point class represents a geometric point with 'x' and 'y' attributes and has many helpful properties and methods.</p> <p>p = Point() p.is_origin True</p>"},{"location":"api/twod/point/#twod.point.Point.is_origin","title":"<code>is_origin: bool</code>  <code>property</code>","text":"<p>True if and only if x == 0 and y == 0.</p>"},{"location":"api/twod/point/#twod.point.Point.quadrant","title":"<code>quadrant: Quadrant</code>  <code>property</code>","text":"<p>The quadrant in the cartesian plane this point is located in.</p> <p>Possible values are: - Quadrant.FIRST - Quadrant.SECOND - Quadrant.THIRD - Quadrant.FOURTH - Quadrant.ORIGIN - Quadrant.X_AXIS - Quadrant.Y_AXIS</p>"},{"location":"api/twod/point/#twod.point.Point.radius","title":"<code>radius: float</code>  <code>property</code> <code>writable</code>","text":"<p>The distance from this point to the origin.</p>"},{"location":"api/twod/point/#twod.point.Point.radians","title":"<code>radians: float</code>  <code>property</code> <code>writable</code>","text":"<p>The angle in radians measured counter-clockwise from 3 o'clock.</p>"},{"location":"api/twod/point/#twod.point.Point.degrees","title":"<code>degrees: float</code>  <code>property</code> <code>writable</code>","text":"<p>The angle in degrees measured counter-clockwise from 3 o'clock.</p>"},{"location":"api/twod/point/#twod.point.Point.polar","title":"<code>polar: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Polar coordinates tuple: (R, \u03f4).</p> <p>R is the distance from the origin to this point. \u03f4 is the angle (radians) measured counter-clockwise from 3 o'clock.</p>"},{"location":"api/twod/point/#twod.point.Point.polar_deg","title":"<code>polar_deg: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Polar coordinates tuple: (R, \u03f4).</p> <p>R is the distance from the origin to this point. \u03f4 is the angle (degrees) measured counter-clockwise from 3 o'clock.</p>"},{"location":"api/twod/point/#twod.point.Point.xy","title":"<code>xy: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>A tuple of this point's x and y coordinates.</p>"},{"location":"api/twod/point/#twod.point.Point-functions","title":"Functions","text":""},{"location":"api/twod/point/#twod.point.Point.from_polar","title":"<code>from_polar(radius: float, theta: float, is_radians: bool = True, translate: Optional[Point] = None) -&gt; Point</code>  <code>classmethod</code>","text":"<p>Returns a Point with polar coordinates (R, \u03f4).</p> <p>The point is genrated relative to the origin.</p> <p>:param float radius: :param float theta: :param bool is_radians: :return: Point</p>"},{"location":"api/twod/point/#twod.point.Point.distance","title":"<code>distance(other: Optional[Point] = None) -&gt; float</code>","text":"<p>Return the floating point distance between self and other.</p> <p>If other is not given, the distance from self to the origin is returned.</p> <p>:param other: Point :return: float</p>"},{"location":"api/twod/point/#twod.point.Point.distance_squared","title":"<code>distance_squared(other: Optional[Point] = None) -&gt; float</code>","text":"<p>Return the floating point squared distance between self and other.</p> <p>If other is not given, the squared distance from self to the origin is returned.</p> <p>:param other: Point :return: float</p>"},{"location":"api/twod/point/#twod.point.Point.dot","title":"<code>dot(other: Point) -&gt; float</code>","text":"<p>Return a scalar dot product of self with other.</p> <p>:param other: Point :return: float</p>"},{"location":"api/twod/point/#twod.point.Point.cross","title":"<code>cross(other: Point) -&gt; float</code>","text":"<p>Return a scalar cross product of self with other.</p> <p>:param other: Point :return: float</p>"},{"location":"api/twod/point/#twod.point.Point.ccw","title":"<code>ccw(b: Point, c: Point) -&gt; float</code>","text":"<p>Return a floating point value indicating the winding direction of the points [self, b, c].</p> <p>If ccw &lt; 0,  clock-wise winding If ccw &gt; 0,  counter clock-wise winding If ccw == 0, the three points are colinear</p> <p>Note: ccw is also 2*area of the triangle [self, b, c].</p> <p>:param b: Point :param c: Point :return: float</p>"},{"location":"api/twod/point/#twod.point.Point.is_ccw","title":"<code>is_ccw(b: Point, c: Point) -&gt; bool</code>","text":"<p>Return True if the angle [self, b, c] has counter clock-wise winding, else False.</p> <p>Raises the exception ColinearPoints if the points compose a line.</p> <p>:param b: Point :param c: Point :return: bool</p>"},{"location":"api/twod/point/#twod.point.Point.is_colinear","title":"<code>is_colinear(b: Point, c: Point) -&gt; bool</code>","text":"<p>True if the angle [self, b, c ] is a line, else False.</p> <p>:param b: Point :param c: Point :return: bool</p>"},{"location":"api/twod/point/#twod.point.Point.midpoint","title":"<code>midpoint(other: Optional[Point] = None) -&gt; Point</code>","text":"<p>Return a new Point midway between self and other..</p> <p>If other is not given, the midpoint between self and the origin is returned.</p> <p>:param other: Point :return: Point</p>"},{"location":"api/twod/point/#twod.point.Point.between","title":"<code>between(p: Point, q: Point) -&gt; bool</code>","text":"<p>True if self is bounded by the points [p, q], else False</p> <p>The bounds are checked by less than or equal to (&lt;=) so self is considered between if it resides on any of the lines constructed using [p,q].</p> <p>:param p: Point :param q: Point :return: bool</p>"},{"location":"api/twod/point/#twod.point.Point.inside","title":"<code>inside(p: Point, q: Point) -&gt; bool</code>","text":"<p>True if point is bounded by the points (p, q), else False</p> <p>The bounds are checked by less than (&lt;) so point is considered inside if it does not reside on any of the lines constructed using (p,q).</p> <p>:param p: Point :param q: Point :return: bool</p>"},{"location":"api/twod/rect/","title":"rect","text":""},{"location":"api/twod/rect/#twod.rect","title":"<code>twod.rect</code>","text":"<p>a rectangle for humans\u2122</p>"},{"location":"api/twod/rect/#twod.rect-classes","title":"Classes","text":""},{"location":"api/twod/rect/#twod.rect.Rect","title":"<code>Rect(x: float | int = 0, y: float | int = 0, w: float | int = 0, h: float | int = 0)</code>","text":"<p>A rectangle specified by an origin at (x,y) and dimensions (w,h).</p>"},{"location":"api/twod/rect/#twod.rect.Rect-attributes","title":"Attributes","text":""},{"location":"api/twod/rect/#twod.rect.Rect.A","title":"<code>A: Point</code>  <code>property</code>","text":"<p>Point at (x,y).</p>"},{"location":"api/twod/rect/#twod.rect.Rect.B","title":"<code>B: Point</code>  <code>property</code>","text":"<p>Point at (x+w, y).</p>"},{"location":"api/twod/rect/#twod.rect.Rect.C","title":"<code>C: Point</code>  <code>property</code>","text":"<p>Point at (x+w, y+h).</p>"},{"location":"api/twod/rect/#twod.rect.Rect.D","title":"<code>D: Point</code>  <code>property</code>","text":"<p>Point at (x, y+h).</p>"},{"location":"api/twod/rect/#twod.rect.Rect.vertices","title":"<code>vertices: list[Point]</code>  <code>property</code>","text":"<p>The points A, B, C, and D in a list.</p>"},{"location":"api/twod/rect/#twod.rect.Rect.sides","title":"<code>sides: list[float]</code>  <code>property</code>","text":"<p>The lengths of each side: AB, BC, CD, and DA.</p>"},{"location":"api/twod/rect/#twod.rect.Rect.center","title":"<code>center: Point</code>  <code>property</code> <code>writable</code>","text":"<p>Point at the center of the rectangle (midpoint of AC).</p>"},{"location":"api/twod/rect/#twod.rect.Rect.perimeter","title":"<code>perimeter: float</code>  <code>property</code>","text":"<p>The distance around this rectangle.</p>"},{"location":"api/twod/rect/#twod.rect.Rect.area","title":"<code>area: float</code>  <code>property</code>","text":"<p>The area of this rectangle.</p>"}]}